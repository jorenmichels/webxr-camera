<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebXR Camera Feed on Cube</title>
  <style>
    body { margin: 0; overflow: hidden; }
    button {
      position: absolute;
      z-index: 10;
      top: 20px;
      left: 20px;
      padding: 12px 18px;
      font-size: 16px;
    }
  </style>
</head>
<body>
<button id="startAR">Start AR</button>
<canvas id="xr-canvas"></canvas>

<script>
const canvas = document.getElementById("xr-canvas");
const gl = canvas.getContext("webgl", { xrCompatible: true });

let xrSession = null;
let xrRefSpace = null;
let cameraTexture = null;
let cubeRotation = 0;

document.getElementById("startAR").addEventListener("click", async () => {
  if (!navigator.xr) {
    alert("WebXR not supported");
    return;
  }

  xrSession = await navigator.xr.requestSession("immersive-ar", {
    requiredFeatures: ["local"],
    optionalFeatures: ["camera-access"]
  });

  xrSession.updateRenderState({
    baseLayer: new XRWebGLLayer(xrSession, gl)
  });

  xrRefSpace = await xrSession.requestReferenceSpace("local");
  xrSession.requestAnimationFrame(onXRFrame);
});

// --- Simple Shader Setup ---
const vertexShaderSrc = `
attribute vec3 position;
attribute vec2 uv;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
}
`;

const fragmentShaderSrc = `
precision mediump float;
varying vec2 vUv;
uniform sampler2D cameraTex;
void main() {
  gl_FragColor = texture2D(cameraTex, vUv);
}
`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}

function createProgram(gl, vs, fs) {
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  return program;
}

const program = createProgram(
  gl,
  createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc),
  createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc)
);

gl.useProgram(program);

// --- Cube Geometry ---
const cubeVertices = new Float32Array([
  // positions        // uvs
  -0.5,-0.5,-0.5, 0,0,
   0.5,-0.5,-0.5, 1,0,
   0.5, 0.5,-0.5, 1,1,
  -0.5, 0.5,-0.5, 0,1,
]);

const indices = new Uint16Array([0,1,2, 0,2,3]);

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

const ibo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, "position");
const uvLoc = gl.getAttribLocation(program, "uv");

gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 20, 0);

gl.enableVertexAttribArray(uvLoc);
gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 20, 12);

// --- Texture ---
cameraTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, cameraTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

// --- XR Frame Loop ---
function onXRFrame(time, frame) {
  xrSession.requestAnimationFrame(onXRFrame);

  const pose = frame.getViewerPose(xrRefSpace);
  if (!pose) return;

  const glLayer = xrSession.renderState.baseLayer;
  gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  for (const view of pose.views) {
    const viewport = glLayer.getViewport(view);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

    // ---- Get camera texture ----
    const camera = frame.getCamera(view);
    if (camera) {
      gl.bindTexture(gl.TEXTURE_2D, cameraTexture);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        camera
      );
    }

    // Projection & view matrices
    const projectionMatrix = view.projectionMatrix;
    const viewMatrix = pose.transform.inverse.matrix;

    const projLoc = gl.getUniformLocation(program, "projectionMatrix");
    const viewLoc = gl.getUniformLocation(program, "viewMatrix");
    const modelLoc = gl.getUniformLocation(program, "modelMatrix");

    gl.uniformMatrix4fv(projLoc, false, projectionMatrix);
    gl.uniformMatrix4fv(viewLoc, false, viewMatrix);

    cubeRotation += 0.01;

    const modelMatrix = mat4RotationY(cubeRotation);
    gl.uniformMatrix4fv(modelLoc, false, modelMatrix);

    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  }
}

// Simple rotation matrix helper
function mat4RotationY(angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return new Float32Array([
     c,0,s,0,
     0,1,0,0,
    -s,0,c,0,
     0,0,-2,1
  ]);
}
</script>
</body>
</html>
